<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, viewport-fit=cover" />
  <title>Routine for Psychos</title>

  <!--
  =========================
  TASK CONFIGURATION (EDIT THIS)
  =========================
  Global:
    dayStart=HH:MM                      (24h, default 05:00 if omitted)

  Tasks (pipe separated):
    Category | Task name | Sub-title | Recurring | (optional extra tokens...) | freshStartDelay=NDAYS

  Notes:
  - Task name supports <b>...</b> only (everything else is stripped).
  - It is allowed to omit the category or sub-title (just leave it blank)
  - Recurring examples:
      2d   = every 2 days
      2.5d = alternates 2 and 3 days (first time randomized, then flips each completion)
      6.5w = alternates 6 and 7 weeks (first time randomized, then flips each completion)
      3m   = every 3 months
      4y   = every 4 years

    Decimals:
      - Only .5 is supported.
      - Any other decimals (e.g. 2.2d, 3.8w) are treated as .0 (rounded down).

  - Time (optional, HH:MM): makes it a timed task.
      Timed tasks become pending only after that time has passed (and recurring + block allow it).
      When they become pending they move to the top and steal focus once for that occurrence.
      Display name is automatically prefixed like: "18:00 Cook eggs"

      Focus-steal grouping:
        - If multiple timed tasks trigger at EXACTLY the same timestamp, only ONE focus-steal occurs.
        - The task highest in configuration order among that same-time group steals focus.
        - The others in that same-time group do NOT steal focus afterward; they remain pending in config order.

  - freshStartDelay (optional, integer days):
      freshStartDelay=0  => pending immediately on fresh start (default if omitted)
      freshStartDelay=4  => first becomes due 4 routine-days after fresh start (at dayStart boundary)
      Applies to timed tasks too (it delays the first due routine-day that the time trigger belongs to).

  - Block (optional, flexible, case-insensitive):
      You can add ZERO or MORE "block tokens" after Recurring.
      Each token can be its own pipe part OR you can combine multiple tokens in one part
      separated by commas/spaces.

      Supported tokens:
        none
        weekday / weekdays            -> blocks Mon, Tue, Wed, Thu, Fri
        weekend / weekends            -> blocks Sat, Sun

        sun / sunday / sundays
        mon / monday / mondays
        tue / tues / tuesday / tuesdays
        wed / weds / wednesday / wednesdays
        thu / thur / thurs / thursday / thursdays
        fri / friday / fridays
        sat / saturday / saturdays

      Examples:
        Mind | Read | ... | 2d | weekends | tuesday | wednesday
        Mind | Read | ... | 2d | weekend, tue, wed
        Home | Vacuum | ... | 6.5d | weekdays
  -->
  <script id="routine-config" type="text/plain">
dayStart=06:00

# Category | Task name | Sub-title | Recurring | (optional block tokens...) | Time | freshStartDelay=NDAYS
Room | Open <b>CURTAINS</b>, make <b>BED</b> || 1d
Teeth | Remove <b>RETAINER</b> || 1d
Teeth | <b>FLOSS</b> teeth || 1d
Teeth | <b>BRUSH</b> teeth || 1d
Beard | <b>SHAVE</b> beard || 2d
Fast Shower | Fast <b>SHOWER</b> | Cleanse face with Cetaphil | 1d | Mon, Thu, Sat
Fast Shower | Fast <b>SHOWER</b>, use <b>SHAMPOO</b> | Cleanse face with Cetaphil | 1d | Tue, Wed, Fri, Sun
Get Ready | <b>DEODORANT</b>, <b>AFTERSHAVE</b> || 1d
Get Ready | <b>TREAT SKIN</b>? | Ketoconazole/Travocort | 1d
Get Ready | <b>WEAR CLOTHES</b> | or bathrobe | 1d
Get Ready | <b>STYLE HAIR</b>? || 1d
Walk | Take <b>ADHD PILL</b>(?) | Modafinil/Concerta/Ritalin/Strattera | 1d
Walk | Take <b>BANANA</b>(?) &  <b>WATER 0.5L</b> | During walk | 1d
Walk | Morning <b>WALK</b> & order/go for <b>BREAKFAST</b> | 10-30 mins | 1d
Post-Breakfast | Take <b>VITAMIN PILLS</b> 4x | Multi, O-3, D3+K2, Magnesium | 1d
Post-Breakfast | Drink <b>WATER</b> 1L with <b>ELECTROLYTES</b>(?) | Daily total | 1d
Digital | <b>NOTION</b>: group <b>A*</b> only | In 'RECURRING (Admin)'| 1d | weekends
Gym (& Spa) | <b>GYM CLOTHES</b> | T-shirt, shorts, sweatbands, socks+shoes, glasses | 1d | weekends
Gym (& Spa) | <b>TECH</b>: Remarkable, phone, earbuds | Tracker? | 1d | weekends
Gym (& Spa) | <b>GYM</b>: <b>STRENGTH</b> training (<b>TRACK</b> it), <b>(SPA)</b> | Before: supplements? pee? | 1d | Tue, Thu, weekends
Gym (& Spa) | <b>GYM</b>: incline <b>WALKING</b> (<b>TRACK</b> it), <b>(SPA)</b> | Before: pee? | 1d | Mon, Wed, Fri, weekends
Weekend | Process <b>ALEXA TO-DO</b> list || 1d | weekdays
Weekend | Quick <b>MARKET CHECK</b> || 1d | weekdays
Weekend | <b>MESSAGES ONLY</b>: Check <b>W'APP</b>, <b>I'GRAM</b>, <b>T'GRAM</b>, (d. app replies) || 1d | weekdays
Weekend | Must-do only: <b>PLANNED TODAY</b> || 1d | weekdays
Sun | Get <b>SUN</b> | Sun lotion (EltaMD UV SPF 46)? | 2d
Clean | <b>CLEAN</b>/<b>ORGANISE</b> home | incl. dishes | 2.5d | weekends
Clean | <b>CLEAR TRASH</b>? || 3.5d | weekends
Laundry | <b>WASH</b>+<b>DRY SHEETS</b>, <b>MAKE BED</b> || 10d | weekends | freshStartDelay=3
Laundry | <b>WASH</b>+<b>DRY 40°</b> | Towels, underwear, socks, etc. | 2w | weekends | freshStartDelay=7
Laundry | <b>WASH 20°</b> or <b>30°</b>, then hang-<b>DRY</b> | Clothes | 2w | weekends
Laundry | <b>ORGANISE</b> clothes || 2w | weekends | freshStartDelay=10
Laundry | <b>IRON</b> clothes | or have them ironed | 3w | weekends | freshStartDelay=12
Work | <b>NOTION</b> | Wear gloves, blue light glasses? | 1d | weekends

# Timed tasks
End Day | Drink <b>WATER</b> ≥2L | Daily total. Can take it on pre-bed walk (next). | 1d | 00:00
End Day | Go for a pre-bed <b>WALK</b> | >10 mins, walk slowly | 1d | 00:00
End Day | Take <b>SLEEPING</b>, or <b>CALMING PILLS</b>? | Zolpicalm? Melatonin? Mag L-Th, Api, L-Thea. | 1d | 00:00
End Day | <b>SHOWER</b>, <b>CLEANSE</b> face | or take bath, or wash hands | 1d | 00:00
Teeth | <b>FLOSS</b> teeth || 1d | 00:00
Teeth | <b>BRUSH</b> teeth || 1d | 00:00
Teeth | Wear <b>RETAINER</b> | for teeth | 1d | 00:00
Skin | <b>MOISTURISE</b> face | La Roche-Posay Toleraine Repairing, or after-sun | 1d | 00:00
Alarm | Is <b>WAKE-UP ALARM</b> active? || 1d | 00:00
Sleep | Turn <b>OFF LIGHTS</b>/candles, <b>CHARGE PHONE</b>, then <b>SLEEP</b> | Meditate/binaural beats/breathe. NO TV/PHONE! | 1d | 00:00
  </script>

  <style>
    :root{
      --bg: #0b0d12;
      --text: #eef1ff;
      --muted: rgba(238,241,255,.70);
      --muted2: rgba(238,241,255,.52);
      --border: rgba(238,241,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.45);

      --radius: 22px;
      --btnRadius: 18px;

      --padX: 18px;
      --padY: 18px;

      --safeTop: env(safe-area-inset-top, 0px);
      --safeBottom: env(safe-area-inset-bottom, 0px);

      --vvh: 100vh;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 900px at 20% 0%, rgba(125, 92, 255, .18), transparent 55%),
                  radial-gradient(900px 800px at 90% 20%, rgba(0, 211, 255, .10), transparent 50%),
                  var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }

    .wrap {
      height: var(--vvh);
      width: 100vw;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding-top: calc(var(--safeTop) + 12px);
      padding-bottom: calc(var(--safeBottom) + 12px);
      box-sizing: border-box;
    }

    .app {
      width: min(520px, calc(100vw - 24px));
      height: calc(var(--vvh) - var(--safeTop) - var(--safeBottom) - 24px);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .topbar {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--padY) var(--padX);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));
      border-bottom: 1px solid var(--border);
      min-height: 64px;
      box-sizing: border-box;
      z-index: 5;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(238,241,255,.10);
      backdrop-filter: blur(10px);
      max-width: 78%;
      box-sizing: border-box;
    }

    .cat {
      font-size: 14px;
      font-weight: 650;
      letter-spacing: .2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .status {
      position: relative;
      font-size: 12px;
      color: var(--muted2);
      display: inline-flex;
      align-items: center;
      gap: 10px;
      text-align: right;
      user-select: none;
      padding-left: 10px;
    }

    .statusBadge {
      height: 34px;
      display: inline-flex;
      align-items: center;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid rgba(238,241,255,.10);
      background: rgba(255,255,255,.06);
      backdrop-filter: blur(10px);
      box-sizing: border-box;

      font-size: 13px;
      font-weight: 650;
      color: rgba(238,241,255,.86);
      white-space: nowrap;
    }

    .iconBtn {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(238,241,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(238,241,255,.92);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 800;
      line-height: 1;
      cursor: pointer;
      touch-action: manipulation;
      box-shadow: 0 10px 24px rgba(0,0,0,.18);
      padding: 0;
    }
    .iconBtn:active { transform: translateY(1px); }

    .menu {
      position: absolute;
      top: calc(100% + 10px);
      right: 0;
      width: min(240px, calc(100vw - 48px));
      border-radius: 16px;
      border: 1px solid rgba(238,241,255,.12);
      background: rgba(12, 15, 24, .92);
      backdrop-filter: blur(14px);
      box-shadow: 0 18px 44px rgba(0,0,0,.50);
      overflow: hidden;
      display: none;
    }

    .menuItem {
      all: unset;
      box-sizing: border-box;
      width: 100%;
      display: block;
      padding: 12px 12px 10px 12px;
      cursor: pointer;
      position: relative;
    }
    .menuItem:hover { background: rgba(255,255,255,.05); }
    .menuItem:active { background: rgba(255,255,255,.07); }

    .menuTitle {
      font-size: 14px;
      font-weight: 720;
      color: rgba(238,241,255,.92);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .menuHint {
      margin-top: 4px;
      font-size: 12px;
      color: rgba(238,241,255,.58);
      line-height: 1.25;
    }

    .danger .menuTitle { color: rgba(255, 190, 190, .95); }
    .danger .menuHint { color: rgba(255, 190, 190, .68); }

    .menuItem::after{
      content: "";
      position: absolute;
      left: 0;
      bottom: 0;
      height: 3px;
      width: 0%;
      background: rgba(255, 190, 190, .85);
    }
    .menuItem.holding::after{
      animation: holdfill 1.2s linear forwards;
    }
    @keyframes holdfill {
      from { width: 0%; }
      to   { width: 100%; }
    }

    .main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      min-height: 0;
    }

    .content {
      padding: 18px var(--padX) 10px var(--padX);
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-sizing: border-box;
      min-height: 0;
    }

    .taskName {
      font-size: clamp(28px, 4.2vw, 40px);
      font-weight: 320;
      letter-spacing: -0.4px;
      line-height: 1.08;
      margin: 0;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
    }
    .taskName b { font-weight: 900; }

    .subTitle {
      margin: 0;
      font-size: clamp(14px, 2.2vw, 16px);
      font-style: italic;
      color: var(--muted);
      line-height: 1.35;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      min-height: 0;
    }

    .meta {
      padding: 10px var(--padX) 16px var(--padX);
      display: flex;
      flex-direction: column;
      gap: 8px;
      box-sizing: border-box;
    }

    .metaRow {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(238,241,255,.10);
      background: rgba(15,19,32,.55);
    }

    .metaKey {
      font-size: 12px;
      color: var(--muted2);
      letter-spacing: .25px;
      text-transform: uppercase;
      white-space: nowrap;
      user-select: none;
    }

    .metaVal {
      font-size: 13px;
      color: rgba(238,241,255,.90);
      text-align: right;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 70%;
    }

    .metaVal.tapEnabled{
      cursor: pointer;
      user-select: none;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
    }
    .metaVal.tapEnabled:active{
      transform: translateY(1px);
    }

    .controls {
      padding: 14px var(--padX) 16px var(--padX);
      border-top: 1px solid var(--border);
      background: rgba(0,0,0,.08);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      box-sizing: border-box;
    }

    .controls.three { grid-template-columns: 1fr 1fr 1fr; }
    .controls.one { grid-template-columns: 1fr; }

    button {
      border: 0;
      border-radius: var(--btnRadius);
      padding: 14px 12px;
      font-size: 16px;
      font-weight: 720;
      color: var(--text);
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(238,241,255,.12);
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }

    button:active { transform: translateY(1px); }

    .btnPrimary {
      background: linear-gradient(180deg, rgba(130,110,255,.80), rgba(91,70,255,.65));
      border: 1px solid rgba(180,170,255,.25);
    }

    .btnSecondary {
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.05));
    }

    .btnTertiary {
      background: rgba(255,255,255,.06);
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: rgba(0,0,0,.50);
      backdrop-filter: blur(10px);
      z-index: 80;
      box-sizing: border-box;
    }

    .overlayCard {
      width: min(520px, calc(100vw - 32px));
      border-radius: 18px;
      border: 1px solid rgba(238,241,255,.14);
      background: rgba(12, 15, 24, .92);
      box-shadow: 0 22px 70px rgba(0,0,0,.65);
      overflow: hidden;
    }

    .overlayHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 14px 12px 14px;
      border-bottom: 1px solid rgba(238,241,255,.10);
    }

    .overlayTitle {
      font-size: 14px;
      font-weight: 740;
      color: rgba(238,241,255,.92);
      letter-spacing: .2px;
    }

    .overlayBody {
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .overlayLabel {
      font-size: 12px;
      color: rgba(238,241,255,.58);
      letter-spacing: .25px;
      text-transform: uppercase;
    }

    .overlayValue {
      font-size: 16px;
      font-weight: 680;
      color: rgba(238,241,255,.94);
      line-height: 1.25;
      word-break: break-word;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="app card" id="app">
      <div class="topbar" id="topbar">
        <div class="pill" id="catPill">
          <span class="cat" id="catName">—</span>
        </div>

        <div class="status" id="statusArea">
          <span class="statusBadge" id="statusBadge">—</span>
          <button class="iconBtn" id="menuBtn" aria-label="Menu" title="Menu">▾</button>

          <div class="menu" id="menu" role="menu" aria-hidden="true">
            <button class="menuItem danger" id="resetItem" role="menuitem">
              <div class="menuTitle">
                <span>Reset data</span>
                <span style="opacity:.7; font-weight:800;">⟲</span>
              </div>
              <div class="menuHint" id="resetHint">Press & hold to confirm (1.2s)</div>
            </button>
          </div>
        </div>
      </div>

      <div class="main" id="mainArea">
        <div class="content">
          <h1 class="taskName" id="taskName">—</h1>
          <p class="subTitle" id="subTitle">—</p>
        </div>

        <div class="meta" id="metaArea">
          <div class="metaRow">
            <div class="metaKey">Recurring</div>
            <div class="metaVal" id="recurringLine">—</div>
          </div>
          <div class="metaRow" id="blockRow" style="display:none;">
            <div class="metaKey">Block</div>
            <div class="metaVal" id="blockLine">—</div>
          </div>
        </div>

        <div class="controls" id="controls">
          <button class="btnPrimary" id="btnComplete">Complete</button>
          <button class="btnSecondary" id="btnSkip">Skip</button>
          <button class="btnTertiary" id="btnFirst" style="display:none;">First</button>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="tsOverlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="overlayCard" role="document">
      <div class="overlayHeader">
        <div class="overlayTitle">Last completed</div>
        <button class="iconBtn" id="tsOverlayClose" aria-label="Close" title="Close">✕</button>
      </div>
      <div class="overlayBody">
        <div class="overlayLabel">Timestamp</div>
        <div class="overlayValue" id="tsOverlayText">—</div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const STORAGE_KEY = "routine_one_task_v1";

      function setVvh() {
        const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
        document.documentElement.style.setProperty('--vvh', `${Math.round(h)}px`);
      }
      setVvh();
      window.addEventListener('resize', setVvh);
      window.addEventListener('orientationchange', setVvh);
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', setVvh);
        window.visualViewport.addEventListener('scroll', setVvh);
      }

      // tiny bleep for timed focus-steal (unlocks on first user gesture to satisfy mobile autoplay rules)
      let audioCtx = null;
      let audioUnlocked = false;

      const unlockPointerOpts = { capture: true, passive: true };
      const unlockKeyOpts = { capture: true };

      function ensureAudioCtx() {
        if (audioCtx) return audioCtx;
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return null;
        audioCtx = new Ctx();
        return audioCtx;
      }

      function unlockAudio() {
        const ctx = ensureAudioCtx();
        if (!ctx) return;

        if (ctx.state === "suspended") ctx.resume();
        audioUnlocked = true;

        window.removeEventListener("pointerdown", unlockAudio, unlockPointerOpts);
        window.removeEventListener("keydown", unlockAudio, unlockKeyOpts);
      }

      window.addEventListener("pointerdown", unlockAudio, unlockPointerOpts);
      window.addEventListener("keydown", unlockAudio, unlockKeyOpts);

      function playFocusStealBeep() {
        if (!audioUnlocked) return;
        const ctx = ensureAudioCtx();
        if (!ctx) return;

        const t0 = ctx.currentTime;

        const o = ctx.createOscillator();
        const g = ctx.createGain();

        o.type = "sine";
        o.frequency.setValueAtTime(880, t0);

        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.12, t0 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.12);

        o.connect(g);
        g.connect(ctx.destination);

        o.start(t0);
        o.stop(t0 + 0.14);

        o.onended = () => {
          try { o.disconnect(); } catch {}
          try { g.disconnect(); } catch {}
        };
      }

      function readConfigText() {
        const el = document.getElementById("routine-config");
        return (el && el.textContent) ? el.textContent : "";
      }

      function isTimeToken(s) {
        return /^([0-2]\d):([0-5]\d)$/.test(String(s || "").trim());
      }

      function parseFreshStartDelayToken(s) {
        const m = String(s || "").trim().match(/^freshStartDelay\s*=\s*(\d+)\s*$/i);
        if (!m) return null;
        const n = parseInt(m[1], 10);
        if (!Number.isFinite(n) || n < 0) return null;
        return n;
      }

      const MASK = (dow) => (1 << dow);
      const WEEKEND_MASK = MASK(0) | MASK(6);
      const WEEKDAY_MASK = MASK(1) | MASK(2) | MASK(3) | MASK(4) | MASK(5);

      function blockWordToMask(w) {
        const s = String(w || "").trim().toLowerCase();
        if (!s) return null;

        if (s === "none") return { reset: true, mask: 0 };

        if (s === "weekday" || s === "weekdays") return { reset: false, mask: WEEKDAY_MASK };
        if (s === "weekend" || s === "weekends") return { reset: false, mask: WEEKEND_MASK };

        if (s === "sun" || s === "sunday" || s === "sundays") return { reset: false, mask: MASK(0) };
        if (s === "mon" || s === "monday" || s === "mondays") return { reset: false, mask: MASK(1) };
        if (s === "tue" || s === "tues" || s === "tuesday" || s === "tuesdays") return { reset: false, mask: MASK(2) };
        if (s === "wed" || s === "weds" || s === "wednesday" || s === "wednesdays") return { reset: false, mask: MASK(3) };
        if (s === "thu" || s === "thur" || s === "thurs" || s === "thursday" || s === "thursdays") return { reset: false, mask: MASK(4) };
        if (s === "fri" || s === "friday" || s === "fridays") return { reset: false, mask: MASK(5) };
        if (s === "sat" || s === "saturday" || s === "saturdays") return { reset: false, mask: MASK(6) };

        return null;
      }

      function parseBlockMaskFromToken(tok) {
        const raw = String(tok || "").trim();
        if (!raw) return { hadAny: false, reset: false, mask: 0 };

        const pieces = raw.split(/[,\s]+/).map(x => x.trim()).filter(Boolean);
        let mask = 0;
        let hadAny = false;
        let reset = false;

        for (const p of pieces) {
          const res = blockWordToMask(p);
          if (!res) continue;
          hadAny = true;
          if (res.reset) {
            reset = true;
            mask = 0;
            continue;
          }
          mask |= res.mask;
        }

        return { hadAny, reset, mask };
      }

      function parseConfig(text) {
        const lines = text.split(/\r?\n/).map(l => l.trim());
        let dayStart = "05:00";
        const tasks = [];

        for (const raw of lines) {
          if (!raw) continue;
          if (raw.startsWith("#")) continue;

          const m = raw.match(/^dayStart\s*=\s*([0-2]\d):([0-5]\d)\s*$/i);
          if (m) {
            dayStart = `${m[1]}:${m[2]}`;
            continue;
          }

          const parts = raw.split("|").map(p => p.trim());
          if (parts.length < 4) continue;

          const category = parts[0] || "General";
          const nameHtml = parts[1] || "Untitled";
          const subtitle = parts[2] || "";
          const recurring = parts[3] || "1d";

          let time = "";
          let freshStartDelay = 0;
          let blockMask = 0;

          for (let i = 4; i < parts.length; i++) {
            const tok = parts[i];
            if (!tok) continue;

            const fsd = parseFreshStartDelayToken(tok);
            if (fsd !== null) { freshStartDelay = fsd; continue; }

            if (!time && isTimeToken(tok)) { time = tok; continue; }

            const bm = parseBlockMaskFromToken(tok);
            if (bm.hadAny) {
              if (bm.reset) blockMask = 0;
              blockMask |= bm.mask;
              continue;
            }
          }

          tasks.push({
            category,
            nameHtml,
            subtitle,
            recurring,
            time,
            freshStartDelay,
            blockMask
          });
        }

        return { dayStart, tasks };
      }

      function hashStringToInt(str) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }

      function taskId(task) {
        const key = `${task.category}||${task.nameHtml}||${task.subtitle}||${task.recurring}||blockMask=${task.blockMask || 0}||${task.time || ""}||fsd=${task.freshStartDelay || 0}`;
        return "t_" + hashStringToInt(key).toString(36);
      }

      function sanitizeBoldOnly(html) {
        let s = String(html ?? "");
        s = s.replace(/<\s*\/\s*b\s*>/gi, "[[/b]]");
        s = s.replace(/<\s*b[^>]*>/gi, "[[b]]");
        s = s.replace(/<[^>]*>/g, "");
        s = s.replace(/\[\[b\]\]/g, "<b>");
        s = s.replace(/\[\[\/b\]\]/g, "</b>");
        return s;
      }

      function parseDayStart(dayStart) {
        const m = String(dayStart || "05:00").match(/^([0-2]\d):([0-5]\d)$/);
        if (!m) return { h: 5, m: 0 };
        let h = parseInt(m[1], 10);
        let mi = parseInt(m[2], 10);
        if (h > 23) h = 5;
        if (mi > 59) mi = 0;
        return { h, m: mi };
      }

      function parseTimeMinutes(timeStr) {
        const m = String(timeStr || "").trim().match(/^([0-2]\d):([0-5]\d)$/);
        if (!m) return null;
        const hh = parseInt(m[1], 10);
        const mm = parseInt(m[2], 10);
        if (hh > 23 || mm > 59) return null;
        return hh * 60 + mm;
      }

      function getDayStartMs(ts, dayStartHM) {
        const d = new Date(ts);
        const base = new Date(d);
        base.setHours(dayStartHM.h, dayStartHM.m, 0, 0);
        if (ts < base.getTime()) base.setDate(base.getDate() - 1);
        return base.getTime();
      }

      function dayKeyFromDayStartMs(dayStartMs) {
        const d = new Date(dayStartMs);
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const da = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${da}`;
      }

      function triggerMsForRoutineDayStart(dayStartMs, timeMinutes, dayStartHM) {
        const dayStartMin = dayStartHM.h * 60 + dayStartHM.m;
        const hh = Math.floor(timeMinutes / 60);
        const mm = timeMinutes % 60;

        const ds = new Date(dayStartMs);
        const t = new Date(ds.getFullYear(), ds.getMonth(), ds.getDate(), hh, mm, 0, 0);
        if (timeMinutes < dayStartMin) t.setDate(t.getDate() + 1);
        return t.getTime();
      }

      function normalizeRecurringValue(v) {
        let x = Number(v);
        if (!Number.isFinite(x)) return 1;
        if (x < 1) x = 1;

        const flo = Math.floor(x);
        const frac = Math.abs(x - flo);

        if (frac < 1e-9) return flo;
        if (Math.abs(frac - 0.5) < 1e-9) return flo + 0.5;
        return flo;
      }

      function parseRecurring(recStr) {
        const s = String(recStr || "").trim().toLowerCase();
        const m = s.match(/^(\d+(?:\.\d+)?)\s*([dwmy])$/);
        if (!m) return { value: 1, unit: "d", raw: s || "1d" };
        const rawVal = parseFloat(m[1]);
        const unit = m[2];
        return { value: normalizeRecurringValue(rawVal), unit, raw: s };
      }

      function clampDayOfMonth(dateObj, year, monthIndex, day) {
        const maxDay = new Date(year, monthIndex + 1, 0).getDate();
        return Math.min(day, maxDay);
      }

      function addMonthsKeepingDOM(baseMs, months) {
        const d = new Date(baseMs);
        const day = d.getDate();
        const hh = d.getHours(), mm = d.getMinutes(), ss = d.getSeconds(), ms = d.getMilliseconds();

        const m0 = d.getMonth();
        const targetMonth = m0 + months;

        const temp = new Date(d);
        temp.setDate(1);
        temp.setMonth(targetMonth);

        const y = temp.getFullYear();
        const m = temp.getMonth();
        const newDay = clampDayOfMonth(temp, y, m, day);

        const out = new Date(y, m, newDay, hh, mm, ss, ms);
        return out.getTime();
      }

      function addYearsKeepingDOM(baseMs, years) {
        const d = new Date(baseMs);
        const day = d.getDate();
        const month = d.getMonth();
        const hh = d.getHours(), mm = d.getMinutes(), ss = d.getSeconds(), ms = d.getMilliseconds();

        const y = d.getFullYear() + years;
        const newDay = clampDayOfMonth(d, y, month, day);
        const out = new Date(y, month, newDay, hh, mm, ss, ms);
        return out.getTime();
      }

      function isBlockedDay(dateObj, blockMask) {
        if (!blockMask) return false;
        const dow = dateObj.getDay();
        return (blockMask & (1 << dow)) !== 0;
      }

      function addDaysMs(ms, days) {
        const d = new Date(ms);
        d.setDate(d.getDate() + days);
        return d.getTime();
      }

      function shiftForwardToAllowedDayStartForTask(dueDayStartMs, task, dayStartHM) {
        if (!task.blockMask) return dueDayStartMs;

        let ms = dueDayStartMs;
        for (let i = 0; i < 60; i++) {
          if (isBlockedDay(new Date(ms), task.blockMask)) {
            ms = addDaysMs(ms, 1);
            continue;
          }

          if (task.isTimed) {
            const trig = triggerMsForRoutineDayStart(ms, task.timeMinutes, dayStartHM);
            if (isBlockedDay(new Date(trig), task.blockMask)) {
              ms = addDaysMs(ms, 1);
              continue;
            }
          }

          return ms;
        }

        return dueDayStartMs;
      }

      function chooseRoundedUpDown(value, taskState, hadBeenCompletedBefore) {
        const lo = Math.floor(value);
        const hi = Math.ceil(value);

        const last = String(taskState.lastRoundDir || "").toLowerCase();
        const hasValidLast = (last === "up" || last === "down");

        let dir;
        if (!hadBeenCompletedBefore || !hasValidLast) {
          dir = (Math.random() < 0.5) ? "down" : "up";
        } else {
          dir = (last === "up") ? "down" : "up";
        }

        taskState.lastRoundDir = dir;
        return (dir === "up") ? hi : lo;
      }

      function isHalfStep(value) {
        const flo = Math.floor(value);
        const frac = Math.abs(value - flo);
        return Math.abs(frac - 0.5) < 1e-9;
      }

      function chooseRecurringAmount(recurring, taskState, hadBeenCompletedBefore) {
        const v = recurring.value;
        if (!Number.isFinite(v)) return 1;
        if (v % 1 === 0) return v;
        if (isHalfStep(v)) return chooseRoundedUpDown(v, taskState, hadBeenCompletedBefore);
        return Math.floor(v);
      }

      function computeNextDueMs(completedAtMs, dayStartHM, recurring, taskState, hadBeenCompletedBefore) {
        const completedDayStart = getDayStartMs(completedAtMs, dayStartHM);
        const chosen = chooseRecurringAmount(recurring, taskState, hadBeenCompletedBefore);
        const unit = recurring.unit;

        if (unit === "d") return completedDayStart + Math.round(chosen * 86400000);
        if (unit === "w") return completedDayStart + Math.round(chosen * 7 * 86400000);
        if (unit === "m") return addMonthsKeepingDOM(completedDayStart, Math.round(chosen));
        if (unit === "y") return addYearsKeepingDOM(completedDayStart, Math.round(chosen));
        return completedDayStart + 86400000;
      }

      function daysAgoText(lastCompletedMs, nowMs, dayStartHM) {
        if (!lastCompletedMs) return "never";
        const nowDayStart = getDayStartMs(nowMs, dayStartHM);
        const lastDayStart = getDayStartMs(lastCompletedMs, dayStartHM);
        const diffDays = Math.max(0, Math.round((nowDayStart - lastDayStart) / 86400000));
        return `${diffDays}d ago`;
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return { byId: {}, activeId: null, freshStartBaseMs: 0 };
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== "object") return { byId: {}, activeId: null, freshStartBaseMs: 0 };
          if (!parsed.byId || typeof parsed.byId !== "object") parsed.byId = {};
          if (typeof parsed.freshStartBaseMs !== "number") parsed.freshStartBaseMs = 0;
          return parsed;
        } catch {
          return { byId: {}, activeId: null, freshStartBaseMs: 0 };
        }
      }

      function saveState(state) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      const catPill = document.getElementById("catPill");
      const catName = document.getElementById("catName");
      const statusBadge = document.getElementById("statusBadge");
      const taskName = document.getElementById("taskName");
      const subTitle = document.getElementById("subTitle");
      const recurringLine = document.getElementById("recurringLine");
      const blockRow = document.getElementById("blockRow");
      const blockLine = document.getElementById("blockLine");
      const controls = document.getElementById("controls");
      const btnComplete = document.getElementById("btnComplete");
      const btnSkip = document.getElementById("btnSkip");
      const btnFirst = document.getElementById("btnFirst");
      const metaArea = document.getElementById("metaArea");

      const menuBtn = document.getElementById("menuBtn");
      const menu = document.getElementById("menu");
      const resetItem = document.getElementById("resetItem");
      const resetHint = document.getElementById("resetHint");

      const tsOverlay = document.getElementById("tsOverlay");
      const tsOverlayText = document.getElementById("tsOverlayText");
      const tsOverlayClose = document.getElementById("tsOverlayClose");

      function formatTimestamp(ms) {
        const d = new Date(ms);
        const fmt = new Intl.DateTimeFormat(undefined, {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
        return fmt.format(d);
      }

      function openTimestampOverlay(ms) {
        if (!ms || !Number.isFinite(ms) || ms <= 0) return;
        tsOverlayText.textContent = formatTimestamp(ms);
        tsOverlay.style.display = "flex";
        tsOverlay.setAttribute("aria-hidden", "false");
      }

      function closeTimestampOverlay() {
        tsOverlay.style.display = "none";
        tsOverlay.setAttribute("aria-hidden", "true");
      }

      tsOverlayClose.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeTimestampOverlay();
      });

      tsOverlay.addEventListener("click", (e) => {
        if (e.target === tsOverlay) closeTimestampOverlay();
      });

      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && tsOverlay.getAttribute("aria-hidden") === "false") {
          closeTimestampOverlay();
        }
      });

      const cfg = parseConfig(readConfigText());
      const dayStartHM = parseDayStart(cfg.dayStart);

      const tasks = cfg.tasks.map((t, idx) => {
        const id = taskId(t);
        const timeMinutes = t.time ? parseTimeMinutes(t.time) : null;
        const isTimed = !!(t.time && timeMinutes !== null);
        return {
          ...t,
          id,
          order: idx,
          recurringParsed: parseRecurring(t.recurring),
          isTimed,
          timeMinutes,
          freshStartDelay: Number.isFinite(t.freshStartDelay) ? t.freshStartDelay : 0,
          blockMask: Number.isFinite(t.blockMask) ? t.blockMask : 0
        };
      });

      const displayAll = [...tasks].sort((a, b) => {
        if (a.isTimed !== b.isTimed) return a.isTimed ? -1 : 1;
        return a.order - b.order;
      });
      const displayIndexById = Object.fromEntries(displayAll.map((t, i) => [t.id, i]));

      const CATEGORY_PALETTE = [
        { name: "orange", h: 28 },
        { name: "green",  h: 145 },
        { name: "blue",   h: 210 },
        { name: "purple", h: 270 }
      ];

      function pillColorFromIndex(i) {
        const h = CATEGORY_PALETTE[(i % CATEGORY_PALETTE.length + CATEGORY_PALETTE.length) % CATEGORY_PALETTE.length].h;
        return {
          pill: `hsl(${h} 92% 56% / .26)`,
          pillBorder: `hsl(${h} 92% 60% / .34)`
        };
      }

      const taskColorIndexById = (function buildTaskColorIndexMap() {
        const map = {};
        let idx = 0;
        let prevCat = null;

        for (const t of displayAll) {
          if (prevCat !== null && t.category !== prevCat) {
            idx = (idx + 1) % CATEGORY_PALETTE.length;
          }
          map[t.id] = idx;
          prevCat = t.category;
        }

        return map;
      })();

      const state = loadState();

      function ensureTaskState(id) {
        if (!state.byId[id]) state.byId[id] = {};
        const s = state.byId[id];
        if (typeof s.lastCompletedMs !== "number") s.lastCompletedMs = 0;
        if (typeof s.nextDueMs !== "number") s.nextDueMs = 0;
        if (typeof s.skippedDayKey !== "string") s.skippedDayKey = "";
        if (typeof s.lastTimedStealKey !== "string") s.lastTimedStealKey = "";
        if (typeof s.lastRoundDir !== "string") s.lastRoundDir = "";
        return s;
      }

      function todayKey(nowMs) {
        const ds = getDayStartMs(nowMs, dayStartHM);
        return dayKeyFromDayStartMs(ds);
      }

      function effectiveDueDayStartMs(task, taskState) {
        let due = taskState.nextDueMs;
        if (!due) due = getDayStartMs(Date.now(), dayStartHM);
        let aligned = getDayStartMs(due + 1000, dayStartHM);
        aligned = shiftForwardToAllowedDayStartForTask(aligned, task, dayStartHM);
        return aligned;
      }

      function isPending(task, taskState, nowMs) {
        const dueDayStart = effectiveDueDayStartMs(task, taskState);

        if (!task.isTimed) return nowMs >= dueDayStart;

        const triggerMs = triggerMsForRoutineDayStart(dueDayStart, task.timeMinutes, dayStartHM);
        if (isBlockedDay(new Date(triggerMs), task.blockMask)) return false;

        return nowMs >= triggerMs;
      }

      function pendingTasksUnordered(nowMs) {
        const out = [];
        for (const t of tasks) {
          const ts = ensureTaskState(t.id);
          if (isPending(t, ts, nowMs)) out.push(t);
        }
        return out;
      }

      function pendingTasksOrdered(nowMs) {
        const pend = pendingTasksUnordered(nowMs);
        const timed = pend.filter(t => t.isTimed).sort((a, b) => a.order - b.order);
        const regular = pend.filter(t => !t.isTimed).sort((a, b) => a.order - b.order);
        return timed.concat(regular);
      }

      function firstPendingTask(nowMs) {
        const pend = pendingTasksOrdered(nowMs);
        return pend.length ? pend[0] : null;
      }

      function applyTimedFocusSteal(nowMs) {
        const candidates = [];

        for (const t of tasks) {
          if (!t.isTimed) continue;

          const ts = ensureTaskState(t.id);
          if (!isPending(t, ts, nowMs)) continue;

          const dueDayStart = effectiveDueDayStartMs(t, ts);
          const triggerMs = triggerMsForRoutineDayStart(dueDayStart, t.timeMinutes, dayStartHM);
          if (isBlockedDay(new Date(triggerMs), t.blockMask)) continue;

          const stealKey = String(triggerMs);
          if (ts.lastTimedStealKey === stealKey) continue;

          candidates.push({ t, ts, triggerMs, stealKey });
        }

        if (!candidates.length) return false;

        candidates.sort((a, b) => {
          if (a.triggerMs !== b.triggerMs) return a.triggerMs - b.triggerMs;
          return a.t.order - b.t.order;
        });

        const chosenTriggerMs = candidates[0].triggerMs;
        const group = candidates.filter(c => c.triggerMs === chosenTriggerMs);

        for (const c of group) {
          c.ts.lastTimedStealKey = c.stealKey;
        }

        state.activeId = candidates[0].t.id;
        saveState(state);

        playFocusStealBeep();
        return true;
      }

      function pickActiveTask(nowMs) {
        const pend = pendingTasksOrdered(nowMs);
        if (!pend.length) return null;

        if (state.activeId) {
          const t = tasks.find(x => x.id === state.activeId);
          if (t) {
            const ts = ensureTaskState(t.id);
            if (isPending(t, ts, nowMs)) return t;
          }
        }

        const tk = todayKey(nowMs);
        for (const t of pend) {
          const ts = ensureTaskState(t.id);
          if (ts.skippedDayKey !== tk) return t;
        }

        return null;
      }

      function setRecurringTapState(lastCompletedMs) {
        if (!lastCompletedMs || lastCompletedMs <= 0) {
          recurringLine.classList.remove("tapEnabled");
          recurringLine.removeAttribute("role");
          recurringLine.removeAttribute("tabindex");
          delete recurringLine.dataset.lastCompletedMs;
          return;
        }

        recurringLine.classList.add("tapEnabled");
        recurringLine.setAttribute("role", "button");
        recurringLine.setAttribute("tabindex", "0");
        recurringLine.dataset.lastCompletedMs = String(lastCompletedMs);
      }

      recurringLine.addEventListener("click", () => {
        const ms = parseInt(recurringLine.dataset.lastCompletedMs || "0", 10);
        if (!ms) return;
        openTimestampOverlay(ms);
      });

      recurringLine.addEventListener("keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        const ms = parseInt(recurringLine.dataset.lastCompletedMs || "0", 10);
        if (!ms) return;
        e.preventDefault();
        openTimestampOverlay(ms);
      });

      function blockDescription(mask) {
        if (!mask) return "";

        const labels = [];
        let rem = mask;

        if ((rem & WEEKEND_MASK) === WEEKEND_MASK) {
          labels.push("weekends");
          rem &= ~WEEKEND_MASK;
        }

        if ((rem & WEEKDAY_MASK) === WEEKDAY_MASK) {
          labels.push("weekdays");
          rem &= ~WEEKDAY_MASK;
        }

        const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        for (let dow = 0; dow <= 6; dow++) {
          if (rem & (1 << dow)) labels.push(dayNames[dow]);
        }

        if (!labels.length) return "";
        return `${labels.join(", ")}`;
      }

      function renderStatusState(nowMs, kind) {
        const pendCount = pendingTasksUnordered(nowMs).length;
        statusBadge.textContent = `${pendCount} pending`;

        catName.textContent = "—";
        if (catPill) {
          catPill.style.background = "rgba(255,255,255,.06)";
          catPill.style.borderColor = "rgba(238,241,255,.10)";
        }

        metaArea.style.display = "none";
        blockRow.style.display = "none";

        btnComplete.style.display = "none";
        btnSkip.style.display = "none";

        setRecurringTapState(0);

        if (kind === "all_done") {
          taskName.textContent = "All caught up";
          subTitle.style.display = "block";
          subTitle.textContent = "No pending tasks right now.";
          btnFirst.style.display = "none";
          controls.classList.remove("three");
          controls.classList.add("one");
        } else {
          const tk = todayKey(nowMs);
          const pend = pendingTasksOrdered(nowMs);
          const skippedCount = pend.filter(t => ensureTaskState(t.id).skippedDayKey === tk).length;

          taskName.textContent = "Done for now";
          subTitle.style.display = "block";
          subTitle.textContent = `You skipped ${skippedCount} task${skippedCount === 1 ? "" : "s"} today. Press First to revisit.`;

          btnFirst.style.display = "block";
          controls.classList.remove("three");
          controls.classList.add("one");
        }
      }

      function renderTask(task, nowMs) {
        metaArea.style.display = "flex";

        const ts = ensureTaskState(task.id);

        catName.textContent = task.category;
        if (catPill) {
          const idx = taskColorIndexById[task.id] ?? 0;
          const col = pillColorFromIndex(idx);
          catPill.style.background = col.pill;
          catPill.style.borderColor = col.pillBorder;
        }

        const pendCount = pendingTasksUnordered(nowMs).length;
        statusBadge.textContent = `${pendCount} pending`;

        const nameHtml = sanitizeBoldOnly(task.nameHtml);
        taskName.innerHTML = task.isTimed && task.time ? `${task.time} ${nameHtml}` : nameHtml;

        if (task.subtitle) {
          subTitle.style.display = "block";
          subTitle.textContent = task.subtitle;
        } else {
          subTitle.style.display = "none";
          subTitle.textContent = "";
        }

        if (ts.lastCompletedMs && ts.lastCompletedMs > 0) {
          const ago = daysAgoText(ts.lastCompletedMs, nowMs, dayStartHM);
          recurringLine.textContent = `${task.recurring} (last completed ${ago})`;
        } else {
          recurringLine.textContent = `${task.recurring}`;
        }

        setRecurringTapState(ts.lastCompletedMs);

        if (task.blockMask) {
          const desc = blockDescription(task.blockMask);
          if (desc) {
            blockRow.style.display = "flex";
            blockLine.textContent = desc;
          } else {
            blockRow.style.display = "none";
          }
        } else {
          blockRow.style.display = "none";
        }

        // CHANGED: hide Skip if this task is the last in the current pending order (would wrap to first).
        const pendOrdered = pendingTasksOrdered(nowMs);
        const orderedCount = pendOrdered.length;
        const idxInPend = pendOrdered.findIndex(t => t.id === task.id);
        const isLastInPendingOrder = (idxInPend >= 0 && idxInPend === orderedCount - 1);

        const showFirst = (idxInPend > 0);
        const showSkip = (orderedCount > 1) && !isLastInPendingOrder;

        btnComplete.style.display = "block";
        btnSkip.style.display = showSkip ? "block" : "none";
        btnFirst.style.display = showFirst ? "block" : "none";

        const btnCount = 1 + (showSkip ? 1 : 0) + (showFirst ? 1 : 0);
        controls.classList.toggle("three", btnCount === 3);
        controls.classList.toggle("one", btnCount === 1);
      }

      let openDayKey = todayKey(Date.now());

      function handleRoutineDayRollover(nowMs) {
        const tk = todayKey(nowMs);
        if (tk === openDayKey) return false;

        openDayKey = tk;

        for (const t of tasks) {
          const ts = ensureTaskState(t.id);
          if (ts.skippedDayKey && ts.skippedDayKey !== tk) ts.skippedDayKey = "";
        }

        const first = firstPendingTask(nowMs);
        state.activeId = first ? first.id : null;
        saveState(state);

        return true;
      }

      function rerender() {
        const nowMs = Date.now();

        handleRoutineDayRollover(nowMs);
        applyTimedFocusSteal(nowMs);

        const active = pickActiveTask(nowMs);

        if (!active) {
          const pendCount = pendingTasksUnordered(nowMs).length;
          if (pendCount === 0) {
            renderStatusState(nowMs, "all_done");
          } else {
            renderStatusState(nowMs, "done_for_now");
          }
          return;
        }

        renderTask(active, nowMs);
      }

      function scanNextPendingAfter(currentId, nowMs, options) {
        const includeSkipped = !!(options && options.includeSkipped);
        const tk = todayKey(nowMs);
        const startIdx = (displayIndexById[currentId] ?? -1);
        if (startIdx < 0) return null;

        for (let step = 1; step <= displayAll.length; step++) {
          const cand = displayAll[(startIdx + step) % displayAll.length];
          const cs = ensureTaskState(cand.id);
          if (!isPending(cand, cs, nowMs)) continue;

          if (includeSkipped) return cand.id;
          if (cs.skippedDayKey !== tk) return cand.id;
        }
        return null;
      }

      function completeActive() {
        const nowMs = Date.now();
        const t = pickActiveTask(nowMs);
        if (!t) return;

        const tk = todayKey(nowMs);
        const ts = ensureTaskState(t.id);
        const wasSkipped = (ts.skippedDayKey === tk);

        const hadBeenCompletedBefore = (ts.lastCompletedMs && ts.lastCompletedMs > 0);

        ts.lastCompletedMs = nowMs;

        const rec = t.recurringParsed;
        let next = computeNextDueMs(nowMs, dayStartHM, rec, ts, hadBeenCompletedBefore);
        next = getDayStartMs(next + 1000, dayStartHM);
        next = shiftForwardToAllowedDayStartForTask(next, t, dayStartHM);
        ts.nextDueMs = next;

        ts.skippedDayKey = "";

        saveState(state);

        const now2 = Date.now();
        const nextId = scanNextPendingAfter(t.id, now2, { includeSkipped: wasSkipped });

        state.activeId = nextId || null;
        saveState(state);

        rerender();
      }

      // Skip behaves as "Next" when you're already revisiting skipped tasks.
      function skipActive() {
        const nowMs = Date.now();
        const t = pickActiveTask(nowMs);
        if (!t) return;

        const pendCount = pendingTasksOrdered(nowMs).length;
        if (pendCount <= 1) return;

        const tk = todayKey(nowMs);
        const ts = ensureTaskState(t.id);

        const wasAlreadySkipped = (ts.skippedDayKey === tk);

        ts.skippedDayKey = tk;
        saveState(state);

        const now2 = Date.now();
        const tk2 = todayKey(now2);

        let nextId = scanNextPendingAfter(t.id, now2, { includeSkipped: wasAlreadySkipped });

        if (!nextId) {
          const pend2 = pendingTasksOrdered(now2);

          if (wasAlreadySkipped) {
            const idx = pend2.findIndex(x => x.id === t.id);
            if (idx >= 0 && pend2.length > 1) {
              const alt = pend2[(idx + 1) % pend2.length];
              if (alt && alt.id !== t.id) nextId = alt.id;
            } else {
              const alt = pend2.find(x => x.id !== t.id);
              if (alt) nextId = alt.id;
            }
          } else {
            const firstUnskipped = pend2.find(x => ensureTaskState(x.id).skippedDayKey !== tk2);
            if (firstUnskipped) nextId = firstUnskipped.id;
          }
        }

        state.activeId = nextId || null;
        saveState(state);

        rerender();
      }

      function firstPending() {
        const nowMs = Date.now();
        const first = firstPendingTask(nowMs);
        if (!first) {
          state.activeId = null;
          saveState(state);
          rerender();
          return;
        }
        state.activeId = first.id;
        saveState(state);
        rerender();
      }

      let menuOpen = false;

      function openMenu() {
        menu.style.display = "block";
        menu.setAttribute("aria-hidden", "false");
        menuOpen = true;
      }

      function closeMenu() {
        menu.style.display = "none";
        menu.setAttribute("aria-hidden", "true");
        menuOpen = false;
        resetItem.classList.remove("holding");
        resetHint.textContent = "Press & hold to confirm (1.2s)";
      }

      menuBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        menuOpen ? closeMenu() : openMenu();
      });

      window.addEventListener("pointerdown", (e) => {
        if (!menuOpen) return;
        if (menu.contains(e.target) || menuBtn.contains(e.target)) return;
        closeMenu();
      });

      function resetDataNow() {
        closeMenu();
        localStorage.removeItem(STORAGE_KEY);
        location.reload();
      }

      let holdTimer = null;
      let holdFired = false;

      function cancelHold() {
        if (holdTimer) clearTimeout(holdTimer);
        holdTimer = null;
        holdFired = false;
        resetItem.classList.remove("holding");
        resetHint.textContent = "Press & hold to confirm (1.2s)";
      }

      resetItem.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!menuOpen) openMenu();

        holdFired = false;
        resetItem.classList.add("holding");
        resetHint.textContent = "Keep holding…";

        if (holdTimer) clearTimeout(holdTimer);
        holdTimer = setTimeout(() => {
          holdFired = true;
          resetHint.textContent = "Resetting…";
          resetDataNow();
        }, 1200);
      });

      resetItem.addEventListener("pointerup", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!holdFired) cancelHold();
      });

      resetItem.addEventListener("pointerleave", () => {
        if (!holdFired) cancelHold();
      });

      resetItem.addEventListener("pointercancel", () => {
        if (!holdFired) cancelHold();
      });

      btnComplete.addEventListener("click", completeActive);
      btnSkip.addEventListener("click", skipActive);
      btnFirst.addEventListener("click", firstPending);

      (function initDefaults() {
        const nowMs = Date.now();

        if (!state.freshStartBaseMs || typeof state.freshStartBaseMs !== "number" || state.freshStartBaseMs <= 0) {
          state.freshStartBaseMs = getDayStartMs(nowMs, dayStartHM);
        }

        for (const t of tasks) {
          const ts = ensureTaskState(t.id);
          if (!ts.nextDueMs && !ts.lastCompletedMs) {
            const delayDays = Number.isFinite(t.freshStartDelay) ? Math.max(0, Math.floor(t.freshStartDelay)) : 0;
            let due = state.freshStartBaseMs + (delayDays * 86400000);
            due = getDayStartMs(due + 1000, dayStartHM);
            due = shiftForwardToAllowedDayStartForTask(due, t, dayStartHM);
            ts.nextDueMs = due;
          }
        }

        saveState(state);
      })();

      (function clearExpiredSkipsOnLoad() {
        const nowMs = Date.now();
        const tk = todayKey(nowMs);
        for (const t of tasks) {
          const ts = ensureTaskState(t.id);
          if (ts.skippedDayKey && ts.skippedDayKey !== tk) ts.skippedDayKey = "";
        }
        saveState(state);
      })();

      rerender();
      setInterval(rerender, 10 * 1000);
    })();
  </script>
</body>
</html>
